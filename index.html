<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processador de Projetos PX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <style>
        .loader {
            border: 5px solid #4a5568; /* dark-gray */
            border-top: 5px solid #f97316; /* orange */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-blue-900 font-sans text-white">
    <div class="container mx-auto p-4 md:p-8">
        <header class="flex items-center mb-10">
            <img src="assets/logotipo.png" alt="Logotipo" class="h-16 mr-6" onerror="this.style.display='none'">
            <h1 class="text-4xl font-bold">Processador de Projetos PX</h1>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div class="bg-gray-800 p-6 rounded-lg shadow-2xl">
                <h2 class="text-2xl font-semibold mb-4">Função 1: Extrair TAGs para Excel</h2>
                <p class="text-gray-300 mb-6">
                    Envie os PDFs, aguarde a análise e selecione o padrão de TAG correto para iniciar a extração.
                </p>
                <div class="mb-4">
                    <label for="pdf-upload1" class="block text-sm font-medium text-gray-300 mb-2">1. Selecione os arquivos PDF:</label>
                    <input type="file" id="pdf-upload1" multiple accept=".pdf" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-500 file:text-white hover:file:bg-orange-600 cursor-pointer">
                </div>
                
                <div id="pattern-selection-container" class="hidden my-4">
                    <label class="block text-sm font-medium text-gray-300 mb-2">2. Selecione os padrões de TAG encontrados:</label>
                    <div id="pattern-list" class="space-y-2 max-h-40 overflow-y-auto bg-gray-700 p-3 rounded-md border border-gray-600">
                        <!-- Checkboxes serão injetados aqui -->
                    </div>
                </div>

                <button id="process-pdf-btn" class="w-full bg-orange-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-orange-600 transition duration-300 shadow-lg">
                    Analisar PDFs
                </button>
            </div>

            <div class="bg-gray-800 p-6 rounded-lg shadow-2xl">
                <h2 class="text-2xl font-semibold mb-4">Função 2: Pintar TAGs no PDF</h2>
                <p class="text-gray-300 mb-6">
                    Envie os PDFs e a planilha. As TAGs serão pintadas de verde, conforme a coluna opcional <strong>'Quantidade'</strong>.
                </p>
                <div class="mb-4">
                    <label for="pdf-upload2" class="block text-sm font-medium text-gray-300 mb-2">1. Selecione os arquivos PDF:</label>
                    <input type="file" id="pdf-upload2" multiple accept=".pdf" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-500 file:text-white hover:file:bg-orange-600 cursor-pointer">
                </div>
                <div class="mb-4">
                    <label for="excel-upload" class="block text-sm font-medium text-gray-300 mb-2">2. Selecione a planilha Excel:</label>
                    <input type="file" id="excel-upload" accept=".xlsx" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-500 file:text-white hover:file:bg-orange-600 cursor-pointer">
                </div>
                <button id="paint-tags-btn" class="w-full bg-orange-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-orange-600 transition duration-300 shadow-lg">
                    Pintar TAGs e Exportar
                </button>
            </div>
        </main>

        <section id="status-container" class="mt-8 bg-gray-800 p-6 rounded-lg shadow-2xl hidden">
            <h3 class="text-xl font-semibold text-white mb-4">Resultados</h3>
            <div id="loader" class="loader mx-auto my-4 hidden"></div>
            <pre id="status" class="bg-gray-900 p-4 rounded-md text-sm text-gray-300 overflow-auto max-h-60 w-full"></pre>
            <div id="download-links" class="mt-4 grid gap-2"></div>
        </section>
    </div>

    <footer class="text-center p-6 mt-8 text-gray-400 text-sm">
        <p>Desenvolvido por <a href="https://www.linkedin.com/in/felipe-reblin-ehs/" target="_blank" rel="noopener noreferrer" class="text-orange-400 hover:underline">Felipe Reblin</a></p>
    </footer>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

        const processPdfBtn = document.getElementById('process-pdf-btn');
        const paintTagsBtn = document.getElementById('paint-tags-btn');
        const pdfUpload1 = document.getElementById('pdf-upload1');
        const pdfUpload2 = document.getElementById('pdf-upload2');
        const excelUpload = document.getElementById('excel-upload');
        const statusContainer = document.getElementById('status-container');
        const loader = document.getElementById('loader');
        const statusEl = document.getElementById('status');
        const downloadLinksEl = document.getElementById('download-links');
        
        let analysisResults = {
            tokensByFile: new Map(),
            phase: 'initial' 
        };

        function showStatus(message, isLoading = false) {
            statusContainer.classList.remove('hidden');
            statusEl.textContent += message + '\n';
            statusEl.scrollTop = statusEl.scrollHeight;
            loader.classList.toggle('hidden', !isLoading);
        }
        
        function clearStatus() {
            statusContainer.classList.add('hidden');
            statusEl.textContent = '';
            downloadLinksEl.innerHTML = '';
            loader.classList.add('hidden');
            document.getElementById('pattern-selection-container').classList.add('hidden');
            analysisResults.phase = 'initial';
            processPdfBtn.textContent = 'Analisar PDFs';
            processPdfBtn.disabled = false;
        }

        function generateStructure(token) {
            return token.replace(/[A-Z]/g, 'A').replace(/[0-9]/g, 'D');
        }

        async function extractAllTextAndAnnotations(file) {
            const allWords = new Set();
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const annotations = await page.getAnnotations();
                annotations.forEach(ann => {
                    if (ann.contents) ann.contents.split(/\s+/).forEach(w => allWords.add(w));
                });

                const textContent = await page.getTextContent();
                if (textContent.items.length > 0) {
                    const sortedItems = textContent.items.sort((a, b) => {
                        const yA = a.transform[5]; const yB = b.transform[5];
                        const xA = a.transform[4]; const xB = b.transform[4];
                        if (Math.abs(yA - yB) > 2) return yB - yA;
                        return xA - xB;
                    });
                    
                    let currentWord = null;
                    for (const item of sortedItems) {
                        if (!item.str.trim()) continue;
                        if (!currentWord) {
                            currentWord = { text: item.str, y: item.transform[5], x: item.transform[4], width: item.width, height: item.height };
                            continue;
                        }
                        const yDist = Math.abs(item.transform[5] - currentWord.y);
                        const xDist = item.transform[4] - (currentWord.x + currentWord.width);
                        const xThreshold = currentWord.height * 0.9;
                        if (yDist < currentWord.height * 0.5 && xDist >= 0 && xDist < xThreshold) {
                            currentWord.text += item.str;
                            currentWord.width = (item.transform[4] + item.width) - currentWord.x;
                        } else {
                            currentWord.text.split(/\s+/).forEach(w => allWords.add(w));
                            currentWord = { text: item.str, y: item.transform[5], x: item.transform[4], width: item.width, height: item.height };
                        }
                    }
                    if (currentWord) currentWord.text.split(/\s+/).forEach(w => allWords.add(w));
                }
            }
            return allWords;
        }

        function displayPatternChoices(structureMap) {
            const patternList = document.getElementById('pattern-list');
            const container = document.getElementById('pattern-selection-container');
            patternList.innerHTML = '';

            if (structureMap.size === 0) {
                patternList.innerHTML = '<p class="text-gray-400">Nenhum padrão de TAG em potencial foi encontrado.</p>';
                processPdfBtn.disabled = true;
                processPdfBtn.textContent = 'Nenhum Padrão Encontrado';
            } else {
                const sortedStructures = [...structureMap.entries()].sort((a, b) => b[1].count - a[1].count);

                sortedStructures.forEach(([structure, data]) => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center p-1';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `struct-${structure}`;
                    checkbox.value = structure;
                    checkbox.className = 'h-4 w-4 rounded border-gray-500 bg-gray-800 text-orange-500 focus:ring-orange-600';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `struct-${structure}`;
                    label.className = 'ml-3 block text-sm font-medium text-gray-300 select-none';
                    label.textContent = `${structure} (ex: ${data.example}, ${data.count} ocorrências)`;

                    div.appendChild(checkbox);
                    div.appendChild(label);
                    patternList.appendChild(div);
                });
                processPdfBtn.textContent = 'Extrair TAGs Selecionadas';
                processPdfBtn.disabled = false;
                analysisResults.phase = 'selection';
            }
            container.classList.remove('hidden');
        }

        async function startPatternDiscovery() {
            if (pdfUpload1.files.length === 0) {
                alert('Por favor, selecione pelo menos um arquivo PDF.');
                return;
            }
            clearStatus();
            showStatus('Analisando PDFs para encontrar padrões...', true);
            analysisResults.tokensByFile.clear();

            const allPotentialWords = new Set();
            for (const file of pdfUpload1.files) {
                showStatus(`Lendo arquivo: ${file.name}`);
                const wordsForThisFile = await extractAllTextAndAnnotations(file);
                analysisResults.tokensByFile.set(file.name, wordsForThisFile);
                wordsForThisFile.forEach(word => allPotentialWords.add(word));
            }
            
            const structureMap = new Map();
            const genericTokenRegex = /[A-Z0-9][A-Z0-9-]{7,20}/g;

            allPotentialWords.forEach(word => {
                const matches = word.match(genericTokenRegex);
                if (matches) {
                    matches.forEach(token => {
                        const structure = generateStructure(token);
                        if (structure.includes('A') && structure.includes('D') && token.length > 8) {
                            if (!structureMap.has(structure)) {
                                structureMap.set(structure, { count: 0, example: token });
                            }
                            structureMap.get(structure).count++;
                        }
                    });
                }
            });

            showStatus('Análise concluída. Por favor, selecione os padrões corretos abaixo.', false);
            displayPatternChoices(structureMap);
        }

        function extractFinalTags() {
            const selectedStructures = Array.from(document.querySelectorAll('#pattern-list input:checked')).map(cb => cb.value);

            if (selectedStructures.length === 0) {
                alert('Por favor, selecione pelo menos um padrão de TAG.');
                return;
            }

            clearStatus();
            showStatus(`Iniciando extração com os padrões: ${selectedStructures.join(', ')}`, true);

            const data = [];
            for (const [fileName, words] of analysisResults.tokensByFile.entries()) {
                const structureName = fileName.replace('.pdf', '');
                const tagsForThisFile = new Set();
                
                words.forEach(word => {
                    const structure = generateStructure(word);
                    if (selectedStructures.includes(structure)) {
                        tagsForThisFile.add(word);
                    }
                });

                if (tagsForThisFile.size > 0) {
                    showStatus(`  - Encontrados ${tagsForThisFile.size} dados em ${fileName}.`);
                    tagsForThisFile.forEach(tag => {
                        data.push({ 'Nome da Estrutura': structureName, 'TAG': tag });
                    });
                }
            }
            
            if (data.length > 0) {
                generateExcel(data);
                showStatus('Planilha Excel gerada com sucesso!', false);
            } else {
                showStatus('Nenhum dado correspondente aos padrões selecionados foi encontrado.', false);
            }

            clearStatus();
        }

        function generateExcel(data) {
            const worksheet = XLSX.utils.json_to_sheet(data);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Dados Extraídos');
            XLSX.writeFile(workbook, 'dados_extraidos.xlsx');
            showStatus('Download da planilha iniciado.');
        }

        processPdfBtn.addEventListener('click', () => {
            if (analysisResults.phase === 'initial') {
                startPatternDiscovery();
            } else if (analysisResults.phase === 'selection') {
                extractFinalTags();
            }
        });

        // --- FUNÇÃO 2 (PINTAR TAGS) ---
        // O código da Função 2 permanece o mesmo.
        
        paintTagsBtn.addEventListener('click', processAndPaintTags);

        async function processAndPaintTags() {
            if (pdfUpload2.files.length === 0 || !excelUpload.files[0]) {
                alert('Por favor, selecione os arquivos PDF e a planilha Excel.');
                return;
            }
            clearStatus();
            showStatus('Iniciando processo para pintar TAGs...', true);

            try {
                const tagsByStructure = await parseExcel(excelUpload.files[0]);

                for (const file of pdfUpload2.files) {
                    const structureName = file.name.replace('.pdf', '');
                    showStatus(`Processando arquivo: ${file.name}`);

                    if (!tagsByStructure[structureName]) {
                        showStatus(`  - Nenhuma TAG encontrada para '${structureName}'. Pulando.`);
                        continue;
                    }

                    const tagsToFind = tagsByStructure[structureName];
                    const arrayBuffer = await file.arrayBuffer();
                    const modifiedPdfBytes = await highlightTagsInPdf(arrayBuffer, tagsToFind);
                    
                    createDownloadLink(modifiedPdfBytes, `pintado_${file.name}`);
                    showStatus(`  - PDF '${file.name}' modificado e pronto para download.`);
                }
            } catch (error) {
                console.error('Erro no processo de pintura de TAGs:', error);
                showStatus(`Erro: ${error.message}`, false);
            }
            showStatus('Processo concluído!', false);
        }

        async function parseExcel(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        const json = XLSX.utils.sheet_to_json(worksheet);
                        
                        const tagsByStructure = {};
                        json.forEach(row => {
                            const structureName = row['Nome da Estrutura'];
                            const tag = row['TAG'];
                            const quantity = row['Quantidade'] || 1;

                            if (structureName && tag) {
                                if (!tagsByStructure[structureName]) {
                                    tagsByStructure[structureName] = [];
                                }
                                tagsByStructure[structureName].push({
                                    tag: String(tag),
                                    count: parseInt(quantity, 10)
                                });
                            }
                        });
                        resolve(tagsByStructure);
                    } catch (e) {
                        reject(e);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        async function highlightTagsInPdf(pdfBytes, tagsToHighlight) {
            const { PDFDocument, rgb, pushGraphicsState, popGraphicsState, concatTransformationMatrix } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfBytes);
            const pdfBytesCopy = new Uint8Array(pdfBytes);
            const pdfjsDoc = await pdfjsLib.getDocument({ data: pdfBytesCopy }).promise;
            
            const paintCount = {};
            tagsToHighlight.forEach(t => {
                paintCount[t.tag] = 0;
            });

            const pdfLibPages = pdfDoc.getPages();

            for (let i = 0; i < pdfjsDoc.numPages; i++) {
                const pdfjsPage = await pdfjsDoc.getPage(i + 1);
                const pdfLibPage = pdfLibPages[i];
                const textContent = await pdfjsPage.getTextContent();
                
                tagsToHighlight.forEach(tagInfo => {
                    textContent.items.forEach(item => {
                        if (item.str.includes(tagInfo.tag) && paintCount[tagInfo.tag] < tagInfo.count) {
                            pdfLibPage.pushOperators(pushGraphicsState());
                            const [a, b, c, d, e, f] = item.transform;
                            pdfLibPage.pushOperators(concatTransformationMatrix(a, b, c, d, e, f));
                            pdfLibPage.drawRectangle({
                                x: 0,
                                y: -item.height / 4,
                                width: item.width,
                                height: item.height,
                                color: rgb(0, 1, 0),
                                opacity: 0.3,
                            });
                            pdfLibPage.pushOperators(popGraphicsState());
                            paintCount[tagInfo.tag]++;
                        }
                    });
                });
            }
            return await pdfDoc.save();
        }
        
        function createDownloadLink(bytes, filename) {
            const blob = new Blob([bytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.textContent = `Baixar ${filename}`;
            a.className = 'block bg-orange-500 text-white font-bold py-2 px-4 rounded hover:bg-orange-600 text-center transition-colors';
            downloadLinksEl.appendChild(a);
        }

    </script>
</body>
</html>


