<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processador de Projetos PX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <style>
        .loader {
            border: 5px solid #4a5568;
            border-top: 5px solid #f97316;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-blue-900 font-sans text-white">
    <div class="container mx-auto p-4 md:p-8">
        <header class="flex items-center mb-10">
            <img src="assets/logotipo.png" alt="Logotipo" class="h-16 mr-6" onerror="this.style.display='none'">
            <h1 class="text-4xl font-bold">Processador de Projetos PX</h1>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div class="bg-gray-800 p-6 rounded-lg shadow-2xl">
                <h2 class="text-2xl font-semibold mb-4">Função 1: Extrair TAGs para Excel</h2>
                <p class="text-gray-300 mb-6">
                    Envie os PDFs. O sistema reconstruirá textos fragmentados para identificar TAGs de qualquer formato.
                </p>
                <div class="mb-4">
                    <label for="pdf-upload1" class="block text-sm font-medium text-gray-300 mb-2">1. Selecione os arquivos PDF:</label>
                    <input type="file" id="pdf-upload1" multiple accept=".pdf" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-500 file:text-white hover:file:bg-orange-600 cursor-pointer">
                </div>
                
                <div id="pattern-selection-container" class="hidden my-4">
                    <label class="block text-sm font-medium text-gray-300 mb-2">2. Selecione os padrões de TAG encontrados:</label>
                    <div id="pattern-list" class="space-y-2 max-h-40 overflow-y-auto bg-gray-700 p-3 rounded-md border border-gray-600">
                        </div>
                </div>

                <button id="process-pdf-btn" class="w-full bg-orange-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-orange-600 transition duration-300 shadow-lg">
                    Analisar PDFs
                </button>
            </div>

            <div class="bg-gray-800 p-6 rounded-lg shadow-2xl">
                <h2 class="text-2xl font-semibold mb-4">Função 2: Pintar TAGs no PDF</h2>
                <p class="text-gray-300 mb-6">
                    Envie PDFs e Planilha. A pintura se adapta a textos fragmentados e respeita o tamanho exato da TAG.
                </p>
                <div class="mb-4">
                    <label for="pdf-upload2" class="block text-sm font-medium text-gray-300 mb-2">1. Selecione os arquivos PDF:</label>
                    <input type="file" id="pdf-upload2" multiple accept=".pdf" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-500 file:text-white hover:file:bg-orange-600 cursor-pointer">
                </div>
                <div class="mb-4">
                    <label for="excel-upload" class="block text-sm font-medium text-gray-300 mb-2">2. Selecione a planilha Excel:</label>
                    <input type="file" id="excel-upload" accept=".xlsx" class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-500 file:text-white hover:file:bg-orange-600 cursor-pointer">
                </div>
                <button id="paint-tags-btn" class="w-full bg-orange-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-orange-600 transition duration-300 shadow-lg">
                    Pintar TAGs e Exportar
                </button>
            </div>
        </main>

        <section id="status-container" class="mt-8 bg-gray-800 p-6 rounded-lg shadow-2xl hidden">
            <h3 class="text-xl font-semibold text-white mb-4">Resultados</h3>
            <div id="loader" class="loader mx-auto my-4 hidden"></div>
            <pre id="status" class="bg-gray-900 p-4 rounded-md text-sm text-gray-300 overflow-auto max-h-60 w-full"></pre>
            <div id="download-links" class="mt-4 grid gap-2"></div>
        </section>
    </div>

    <footer class="text-center p-6 mt-8 text-gray-400 text-sm">
        <p>Desenvolvido por <a href="https://www.linkedin.com/in/felipe-reblin-ehs/" target="_blank" rel="noopener noreferrer" class="text-orange-400 hover:underline">Felipe Reblin</a></p>
    </footer>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

        const processPdfBtn = document.getElementById('process-pdf-btn');
        const paintTagsBtn = document.getElementById('paint-tags-btn');
        const pdfUpload1 = document.getElementById('pdf-upload1');
        const pdfUpload2 = document.getElementById('pdf-upload2');
        const excelUpload = document.getElementById('excel-upload');
        const statusContainer = document.getElementById('status-container');
        const loader = document.getElementById('loader');
        const statusEl = document.getElementById('status');
        const downloadLinksEl = document.getElementById('download-links');
        
        let analysisResults = {
            tokensByFile: new Map(),
            phase: 'initial' 
        };

        function showStatus(message, isLoading = false) {
            statusContainer.classList.remove('hidden');
            statusEl.textContent += message + '\n';
            statusEl.scrollTop = statusEl.scrollHeight;
            loader.classList.toggle('hidden', !isLoading);
        }
        
        function clearStatus() {
            statusContainer.classList.add('hidden');
            statusEl.textContent = '';
            downloadLinksEl.innerHTML = '';
            loader.classList.add('hidden');
            document.getElementById('pattern-selection-container').classList.add('hidden');
            analysisResults.phase = 'initial';
            processPdfBtn.textContent = 'Analisar PDFs';
            processPdfBtn.disabled = false;
        }

        function generateStructure(token) {
            return token.replace(/[A-Z]/g, 'A').replace(/[0-9]/g, 'D');
        }

        // --- LÓGICA DE RECONSTRUÇÃO DE LINHA (RESOLVE FRAGMENTAÇÃO) ---
        async function extractTextLinesFromPage(page) {
            const textContent = await page.getTextContent();
            if (!textContent.items.length) return [];

            // 1. Agrupar itens por linha visual (Y aproximado)
            const linesMap = new Map();
            const Y_TOLERANCE = 4; // Tolerância para desalinhamento vertical

            textContent.items.forEach(item => {
                if (!item.str.trim()) return; // Ignora itens vazios
                
                // Normaliza Y para agrupar
                const y = item.transform[5];
                let foundY = null;
                for (const key of linesMap.keys()) {
                    if (Math.abs(key - y) < Y_TOLERANCE) {
                        foundY = key;
                        break;
                    }
                }
                const key = foundY !== null ? foundY : y;
                if (!linesMap.has(key)) linesMap.set(key, []);
                linesMap.get(key).push(item);
            });

            const fullLines = [];

            // 2. Para cada linha, ordenar por X e concatenar
            linesMap.forEach(items => {
                items.sort((a, b) => a.transform[4] - b.transform[4]); // Ordena por X
                
                let lineStr = "";
                let lastX = null;
                let lastWidth = 0;

                items.forEach(item => {
                    if (lastX !== null) {
                        // Se houver um buraco grande, insere espaço
                        const gap = item.transform[4] - (lastX + lastWidth);
                        // Estima largura do caractere
                        const charWidth = item.width / Math.max(1, item.str.length);
                        if (gap > charWidth * 0.5) { // Se gap > meio caractere, assume espaço
                             lineStr += " "; 
                        }
                    }
                    lineStr += item.str;
                    lastX = item.transform[4];
                    lastWidth = item.width;
                });
                fullLines.push(lineStr);
            });

            return fullLines;
        }

        async function extractAllTextAndAnnotations(file) {
            const allWords = new Set();
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                
                // Anotações
                const annotations = await page.getAnnotations();
                annotations.forEach(ann => {
                    if (ann.contents) {
                        // Quebra anotações em tokens para análise
                        ann.contents.split(/[\s\n]+/).forEach(w => allWords.add(w));
                    }
                });

                // Texto do corpo (usando a lógica robusta de linhas)
                const lines = await extractTextLinesFromPage(page);
                lines.forEach(line => {
                    // Divide a linha reconstruída em tokens para encontrar TAGs
                    line.split(/[\s\n]+/).forEach(w => allWords.add(w));
                });
            }
            return allWords;
        }

        function displayPatternChoices(structureMap) {
            const patternList = document.getElementById('pattern-list');
            const container = document.getElementById('pattern-selection-container');
            patternList.innerHTML = '';

            if (structureMap.size === 0) {
                patternList.innerHTML = '<p class="text-gray-400">Nenhum padrão de TAG em potencial foi encontrado.</p>';
                processPdfBtn.disabled = true;
                processPdfBtn.textContent = 'Nenhum Padrão Encontrado';
            } else {
                const sortedStructures = [...structureMap.entries()].sort((a, b) => b[1].count - a[1].count);

                sortedStructures.forEach(([structure, data]) => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center p-1';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `struct-${structure}`;
                    checkbox.value = structure;
                    checkbox.className = 'h-4 w-4 rounded border-gray-500 bg-gray-800 text-orange-500 focus:ring-orange-600';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `struct-${structure}`;
                    label.className = 'ml-3 block text-sm font-medium text-gray-300 select-none';
                    label.textContent = `${structure} (ex: ${data.example}, ${data.count} ocorrências)`;

                    div.appendChild(checkbox);
                    div.appendChild(label);
                    patternList.appendChild(div);
                });
                processPdfBtn.textContent = 'Extrair TAGs Selecionadas';
                processPdfBtn.disabled = false;
                analysisResults.phase = 'selection';
            }
            container.classList.remove('hidden');
        }

        async function startPatternDiscovery() {
            if (pdfUpload1.files.length === 0) {
                alert('Por favor, selecione pelo menos um arquivo PDF.');
                return;
            }
            clearStatus();
            showStatus('Analisando PDFs para encontrar padrões...', true);
            analysisResults.tokensByFile.clear();

            const allPotentialWords = new Set();
            for (const file of pdfUpload1.files) {
                showStatus(`Lendo arquivo: ${file.name}`);
                const wordsForThisFile = await extractAllTextAndAnnotations(file);
                analysisResults.tokensByFile.set(file.name, wordsForThisFile);
                wordsForThisFile.forEach(word => allPotentialWords.add(word));
            }
            
            const structureMap = new Map();
            // Regex flexível: aceita letras, números, hífen, ponto. Min 3 chars.
            const genericTokenRegex = /[A-Z0-9\-\.]{3,}/g;

            allPotentialWords.forEach(word => {
                const matches = word.match(genericTokenRegex);
                if (matches) {
                    matches.forEach(token => {
                        // Filtro básico para evitar lixo muito curto
                        if (token.length >= 3) {
                            const structure = generateStructure(token);
                            if (!structureMap.has(structure)) {
                                structureMap.set(structure, { count: 0, example: token });
                            }
                            structureMap.get(structure).count++;
                        }
                    });
                }
            });

            showStatus('Análise concluída. Selecione os padrões.', false);
            displayPatternChoices(structureMap);
        }

        function extractFinalTags() {
            const selectedStructures = Array.from(document.querySelectorAll('#pattern-list input:checked')).map(cb => cb.value);

            if (selectedStructures.length === 0) {
                alert('Por favor, selecione pelo menos um padrão de TAG.');
                return;
            }

            clearStatus();
            showStatus(`Extraindo dados...`, true);

            const data = [];
            for (const [fileName, words] of analysisResults.tokensByFile.entries()) {
                const structureName = fileName.replace('.pdf', '');
                const tagsForThisFile = new Set();
                
                words.forEach(word => {
                    if (/[A-Z0-9\-\.]{3,}/.test(word)) {
                        const structure = generateStructure(word);
                        if (selectedStructures.includes(structure)) {
                            tagsForThisFile.add(word);
                        }
                    }
                });

                if (tagsForThisFile.size > 0) {
                    tagsForThisFile.forEach(tag => {
                        data.push({ 'Nome da Estrutura': structureName, 'TAG': tag });
                    });
                }
            }
            
            if (data.length > 0) {
                generateExcel(data);
                showStatus('Planilha gerada!', false);
            } else {
                showStatus('Nenhum dado encontrado.', false);
            }
            clearStatus();
        }

        function generateExcel(data) {
            const worksheet = XLSX.utils.json_to_sheet(data);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Dados Extraídos');
            XLSX.writeFile(workbook, 'dados_extraidos.xlsx');
            showStatus('Download iniciado.');
        }

        processPdfBtn.addEventListener('click', () => {
            if (analysisResults.phase === 'initial') {
                startPatternDiscovery();
            } else if (analysisResults.phase === 'selection') {
                extractFinalTags();
            }
        });

        // --- FUNÇÃO 2 (PINTURA AVANÇADA) ---
        
        paintTagsBtn.addEventListener('click', processAndPaintTags);

        async function processAndPaintTags() {
            if (pdfUpload2.files.length === 0 || !excelUpload.files[0]) {
                alert('Faltam arquivos.');
                return;
            }
            clearStatus();
            showStatus('Iniciando pintura de TAGs...', true);

            try {
                const tagsByStructure = await parseExcel(excelUpload.files[0]);

                for (const file of pdfUpload2.files) {
                    const structureName = file.name.replace('.pdf', '');
                    showStatus(`Processando: ${file.name}`);

                    if (!tagsByStructure[structureName]) {
                        showStatus(`  - Sem TAGs na planilha para este arquivo. Pulando.`);
                        continue;
                    }

                    const tagsToFind = tagsByStructure[structureName];
                    const arrayBuffer = await file.arrayBuffer();
                    const modifiedPdfBytes = await highlightTagsInPdf(arrayBuffer, tagsToFind);
                    
                    createDownloadLink(modifiedPdfBytes, `pintado_${file.name}`);
                }
            } catch (error) {
                console.error(error);
                showStatus(`Erro: ${error.message}`, false);
            }
            showStatus('Concluído!', false);
        }

        async function parseExcel(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        const json = XLSX.utils.sheet_to_json(worksheet);
                        
                        const tagsByStructure = {};
                        json.forEach(row => {
                            const structureName = row['Nome da Estrutura'];
                            const tag = row['TAG'];
                            const quantity = row['Quantidade'] || 1;
                            if (structureName && tag) {
                                if (!tagsByStructure[structureName]) tagsByStructure[structureName] = [];
                                tagsByStructure[structureName].push({ tag: String(tag), count: parseInt(quantity, 10) });
                            }
                        });
                        resolve(tagsByStructure);
                    } catch (e) { reject(e); }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        async function highlightTagsInPdf(pdfBytes, tagsToHighlight) {
            const { PDFDocument, rgb, pushGraphicsState, popGraphicsState, concatTransformationMatrix } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfBytes);
            const pdfBytesCopy = new Uint8Array(pdfBytes);
            const pdfjsDoc = await pdfjsLib.getDocument({ data: pdfBytesCopy }).promise;
            
            const paintCount = {};
            tagsToHighlight.forEach(t => paintCount[t.tag] = 0);

            const pdfLibPages = pdfDoc.getPages();

            for (let i = 0; i < pdfjsDoc.numPages; i++) {
                const pdfjsPage = await pdfjsDoc.getPage(i + 1);
                const pdfLibPage = pdfLibPages[i];
                const textContent = await pdfjsPage.getTextContent();
                
                if (!textContent.items.length) continue;

                // --- MAPA DE TEXTO (Char Map) ---
                // Transforma a "sopa de itens" em uma string linear com referências
                // Permite encontrar TAGs quebradas entre múltiplos itens
                
                // 1. Ordena itens (Y desc, X asc)
                const items = textContent.items.sort((a, b) => {
                     const yA = a.transform[5]; const yB = b.transform[5];
                     if (Math.abs(yA - yB) > 4) return yB - yA; // Linha diferente
                     return a.transform[4] - b.transform[4]; // Mesma linha, ordena X
                });

                let fullText = "";
                const charMap = []; // Índice na fullText -> { item, charIndexInItem }

                let lastItem = null;
                items.forEach(item => {
                    // Detecção simples de espaço visual
                    if (lastItem) {
                        const yDiff = Math.abs(item.transform[5] - lastItem.transform[5]);
                        const xDiff = item.transform[4] - (lastItem.transform[4] + lastItem.width);
                        const isSameLine = yDiff < 5;
                        
                        // Se for mesma linha e gap > 30% da altura (heurística), insere espaço
                        if (isSameLine && xDiff > (item.height * 0.3)) {
                            fullText += " ";
                            charMap.push(null); // Espaço não tem item físico
                        } else if (!isSameLine) {
                            fullText += "\n";
                            charMap.push(null);
                        }
                    }

                    for (let c = 0; c < item.str.length; c++) {
                        fullText += item.str[c];
                        charMap.push({ item, idx: c, totalLen: item.str.length });
                    }
                    lastItem = item;
                });

                // --- BUSCA E PINTURA ---
                tagsToHighlight.forEach(tagInfo => {
                    const tag = tagInfo.tag;
                    if (paintCount[tag] >= tagInfo.count) return;

                    // Busca todas as ocorrências na string reconstruída
                    let startIndex = 0;
                    while ((startIndex = fullText.indexOf(tag, startIndex)) !== -1) {
                        if (paintCount[tag] >= tagInfo.count) break;

                        const endIndex = startIndex + tag.length;
                        
                        // Recupera os itens envolvidos nesta TAG
                        const involvedItems = new Set();
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        let validMatch = true;

                        // Verifica quais itens físicos compõem essa string encontrada
                        const partsToPaint = []; // { item, startChar, endChar }

                        for (let k = startIndex; k < endIndex; k++) {
                            const mapData = charMap[k];
                            if (mapData) { // Se não for espaço virtual
                                const existingPart = partsToPaint.find(p => p.item === mapData.item);
                                if (existingPart) {
                                    existingPart.endChar = mapData.idx;
                                } else {
                                    partsToPaint.push({ item: mapData.item, startChar: mapData.idx, endChar: mapData.idx });
                                }
                            }
                        }

                        if (partsToPaint.length > 0) {
                            partsToPaint.forEach(part => {
                                const item = part.item;
                                // Cálculo Preciso da Largura (Ajuste pedido pelo usuário)
                                // Se a TAG é substring (ex: achou "123" dentro de "TAG123"),
                                // Calculamos a fração da largura.
                                
                                const charWidthAvg = item.width / part.item.str.length;
                                const partLength = (part.endChar - part.startChar) + 1;
                                
                                const drawX = item.transform[4] + (part.startChar * charWidthAvg);
                                const drawWidth = partLength * charWidthAvg;
                                const drawY = item.transform[5];
                                const drawHeight = item.height;

                                pdfLibPage.pushOperators(pushGraphicsState());
                                // Nota: Usando coordenadas brutas simplificadas para fragmentos
                                // Para maior precisão em rotações complexas, o ideal seria concatTransformationMatrix,
                                // mas para "recortes" parciais, o cálculo manual de X é mais controlável aqui.
                                
                                pdfLibPage.drawRectangle({
                                    x: drawX,
                                    y: drawY - (drawHeight * 0.1), // Ajuste baseline
                                    width: drawWidth,
                                    height: drawHeight * 0.85,     // Ajuste altura
                                    color: rgb(0, 1, 0),
                                    opacity: 0.3,
                                });
                                pdfLibPage.pushOperators(popGraphicsState());
                            });
                            
                            paintCount[tag]++;
                        }
                        
                        startIndex = endIndex; // Avança busca
                    }
                });
            }
            return await pdfDoc.save();
        }
        
        function createDownloadLink(bytes, filename) {
            const blob = new Blob([bytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.textContent = `Baixar ${filename}`;
            a.className = 'block bg-orange-500 text-white font-bold py-2 px-4 rounded hover:bg-orange-600 text-center transition-colors';
            downloadLinksEl.appendChild(a);
        }
    </script>
</body>
</html>
